# Vikingship 组件技术文档

## 一、Upload 组件

### 1. 使用场景和目的

**使用场景：**
- 文件上传功能：用户需要上传图片、文档、视频等文件
- 表单提交：在表单中需要上传附件
- 头像上传：用户头像、个人资料图片上传
- 批量上传：支持一次选择多个文件上传
- 拖拽上传：提供更好的用户体验，支持拖拽文件到指定区域

**目的：**
- 提供统一的文件上传交互界面
- 支持上传进度显示，让用户了解上传状态
- 支持文件上传前验证（大小、类型等）
- 提供上传成功/失败的反馈
- 支持文件列表管理和删除功能

### 2. 底层实现（原理）

**核心原理：**

1. **文件选择机制**
   - 使用隐藏的 `<input type="file">` 元素
   - 通过 `ref` 引用，点击触发区域时调用 `fileInput.current.click()` 触发文件选择
   - 支持 `accept` 属性限制文件类型
   - 支持 `multiple` 属性实现多文件选择

2. **文件上传机制**
   - 使用 `FormData` API 构建表单数据
   - 通过 `axios` 发送 POST 请求
   - 利用 `onUploadProgress` 回调监听上传进度
   - 计算进度：`percentage = (e.loaded * 100) / e.total`

3. **状态管理**
   - 使用 `useState` 管理文件列表 `fileList`
   - 每个文件包含：`uid`（唯一标识）、`name`、`size`、`status`（ready/uploading/success/error）、`percent`、`raw`（原始文件对象）、`response`（服务器响应）、`error`（错误信息）

4. **拖拽上传实现**
   - 使用 HTML5 Drag and Drop API
   - `onDragOver`：阻止默认行为，设置拖拽悬停状态
   - `onDragLeave`：取消悬停状态
   - `onDrop`：获取 `e.dataTransfer.files`，触发上传

5. **文件列表更新策略**
   - `updateFileList` 函数通过 `uid` 匹配更新特定文件状态
   - 使用函数式更新确保状态一致性

### 3. 使用方式和实现细节

**基本使用：**
```tsx
<Upload
  action="https://api.example.com/upload"
  onSuccess={(data, file) => console.log('上传成功', data, file)}
  onChange={(file) => console.log('文件状态变化', file)}
>
  <Button>点击上传</Button>
</Upload>
```

**文件大小验证：**
```tsx
const checkFileSize = (file: File) => {
  if (file.size > 50 * 1024) {
    alert('文件太大')
    return false
  }
  return true
}

<Upload
  action="https://api.example.com/upload"
  beforeUpload={checkFileSize}
>
  <Button>上传（限制50KB）</Button>
</Upload>
```

**拖拽上传：**
```tsx
<Upload
  action="https://api.example.com/upload"
  drag
  multiple
>
  <Icon icon="upload" size="5x" />
  <p>点击或拖拽文件到此区域上传</p>
</Upload>
```

**实现细节：**

1. **组件结构**
   - `Upload`：主组件，管理上传逻辑
   - `Dragger`：拖拽容器组件
   - `UploadList`：文件列表展示组件

2. **关键函数**
   - `handleClick`：触发文件选择
   - `handleFileChange`：处理文件选择变化
   - `uploadFiles`：处理文件上传（支持 beforeUpload 验证）
   - `post`：执行实际上传请求
   - `handleRemove`：删除文件

3. **生命周期处理**
   - 文件选择后立即添加到列表（status: 'ready'）
   - 上传过程中更新进度（status: 'uploading'）
   - 上传成功/失败更新状态并触发回调

4. **错误处理**
   - 捕获 axios 请求错误
   - 更新文件状态为 'error'
   - 调用 `onError` 回调

### 4. 竞对方案及其优缺点对比

**Ant Design Upload：**
- ✅ 优点：功能完善，支持更多场景（图片预览、自定义请求、分片上传）
- ❌ 缺点：体积较大，API 复杂，学习成本高

**Element UI Upload：**
- ✅ 优点：API 简洁，文档清晰
- ❌ 缺点：Vue 生态，React 项目不适用

**React-Dropzone：**
- ✅ 优点：专注拖拽上传，API 简单
- ❌ 缺点：功能单一，需要自己实现上传逻辑

**Vikingship Upload：**
- ✅ 优点：轻量级，API 简洁，易于定制
- ❌ 缺点：功能相对简单，不支持分片上传、断点续传等高级功能

### 5. 延伸到的技术栈的八股

**React Hooks：**
- `useState`：管理组件状态
- `useRef`：获取 DOM 引用，存储不需要触发渲染的值
- `useEffect`：副作用处理（本项目未使用，但可用于清理）

**HTML5 API：**
- `FormData`：构建表单数据
- `File API`：文件对象操作
- `Drag and Drop API`：拖拽功能

**HTTP 请求：**
- `axios`：HTTP 客户端库
- `multipart/form-data`：文件上传的 Content-Type
- `onUploadProgress`：上传进度监听

**TypeScript：**
- 接口定义：`UploadProps`、`UploadFile`
- 类型约束：`UploadFileStatus` 联合类型
- 泛型使用：组件泛型约束

**React 模式：**
- 受控组件：通过 props 控制组件行为
- 非受控组件：内部状态管理
- 组合模式：通过 children 自定义触发区域

### 6. 如果不用库让你自己实现该怎么做

**核心实现步骤：**

1. **创建隐藏的文件输入**
```tsx
const fileInputRef = useRef<HTMLInputElement>(null)
<input
  ref={fileInputRef}
  type="file"
  style={{ display: 'none' }}
  onChange={handleFileChange}
/>
```

2. **实现文件上传函数**
```tsx
const uploadFile = async (file: File) => {
  const formData = new FormData()
  formData.append('file', file)
  
  const xhr = new XMLHttpRequest()
  
  // 监听上传进度
  xhr.upload.onprogress = (e) => {
    if (e.lengthComputable) {
      const percent = Math.round((e.loaded * 100) / e.total)
      updateProgress(percent)
    }
  }
  
  // 处理响应
  xhr.onload = () => {
    if (xhr.status === 200) {
      handleSuccess(JSON.parse(xhr.responseText))
    } else {
      handleError(new Error('Upload failed'))
    }
  }
  
  xhr.open('POST', action)
  xhr.send(formData)
}
```

3. **实现拖拽功能**
```tsx
const handleDragOver = (e: DragEvent) => {
  e.preventDefault()
  setDragOver(true)
}

const handleDrop = (e: DragEvent) => {
  e.preventDefault()
  setDragOver(false)
  const files = e.dataTransfer.files
  handleFiles(files)
}
```

4. **状态管理**
```tsx
interface FileItem {
  uid: string
  name: string
  status: 'ready' | 'uploading' | 'success' | 'error'
  percent: number
  file: File
}

const [fileList, setFileList] = useState<FileItem[]>([])
```

### 7. 在此之上还能否做优化

**性能优化：**
1. **虚拟滚动**：文件列表很长时使用虚拟滚动
2. **请求取消**：支持取消正在上传的文件
3. **并发控制**：限制同时上传的文件数量
4. **文件压缩**：上传前压缩图片文件

**功能增强：**
1. **分片上传**：大文件分片上传，支持断点续传
2. **图片预览**：上传前预览图片
3. **文件类型图标**：根据文件类型显示不同图标
4. **上传队列管理**：支持暂停、继续、重试
5. **自定义请求方法**：支持 PUT、PATCH 等
6. **自定义上传组件**：支持自定义上传逻辑（如上传到云存储）

**用户体验优化：**
1. **拖拽区域高亮**：更明显的视觉反馈
2. **上传速度显示**：显示上传速度（MB/s）
3. **文件大小格式化**：友好显示文件大小（KB、MB、GB）
4. **错误重试**：失败文件支持一键重试
5. **批量操作**：支持批量删除、批量重试

**代码优化：**
1. **自定义 Hook**：提取 `useUpload` Hook
2. **错误边界**：添加错误边界处理
3. **TypeScript 严格模式**：更严格的类型检查
4. **单元测试覆盖**：提高测试覆盖率
5. **性能监控**：添加性能监控和上报

---

## 二、AutoComplete 组件

### 1. 使用场景和目的

**使用场景：**
- 搜索框自动补全：用户输入时显示相关建议
- 地址选择：输入地址时显示匹配的地址列表
- 用户名搜索：输入用户名时显示匹配的用户
- 商品搜索：电商网站的商品搜索建议
- API 数据查询：根据输入查询远程数据并显示结果

**目的：**
- 提升用户体验：减少用户输入，快速选择
- 减少输入错误：通过建议列表避免拼写错误
- 提高搜索效率：快速定位目标内容
- 支持键盘操作：通过方向键和回车键选择

### 2. 底层实现（原理）

**核心原理：**

1. **输入监听**
   - 监听 `Input` 组件的 `onChange` 事件
   - 使用 `useDebounce` Hook 防抖，避免频繁请求
   - 默认 300ms 防抖延迟

2. **数据获取**
   - `fetchSuggestions` 函数可以是同步或异步
   - 同步：直接返回过滤后的数组
   - 异步：返回 Promise，显示 loading 状态

3. **下拉列表渲染**
   - 使用 `Transition` 组件实现动画效果
   - 通过 `showDropdown` 状态控制显示/隐藏
   - 使用 `useClickOutside` Hook 实现点击外部关闭

4. **键盘导航**
   - `keyCode 38`（↑）：向上移动高亮
   - `keyCode 40`（↓）：向下移动高亮
   - `keyCode 13`（Enter）：选择当前高亮项
   - `keyCode 27`（Esc）：关闭下拉列表

5. **高亮管理**
   - `highlightIndex` 状态记录当前高亮索引
   - 通过 `classNames` 动态添加 `is-active` 类

6. **选择处理**
   - 点击或回车选择后，更新输入框值
   - 设置 `triggerSearch.current = false` 防止选择后触发搜索
   - 调用 `onSelect` 回调

### 3. 使用方式和实现细节

**基本使用（同步）：**
```tsx
const lakers = ['james', 'kobe', 'curry', 'durant']

const handleFetch = (query: string) => {
  return lakers
    .filter(name => name.includes(query))
    .map(name => ({ value: name }))
}

<AutoComplete
  fetchSuggestions={handleFetch}
  placeholder="输入球员名字"
  onSelect={(item) => console.log('选择了', item)}
/>
```

**异步搜索：**
```tsx
const handleFetch = (query: string) => {
  return fetch(`https://api.github.com/search/users?q=${query}`)
    .then(res => res.json())
    .then(({ items }) => {
      return items.slice(0, 10).map((item: any) => ({
        value: item.login,
        ...item
      }))
    })
}

<AutoComplete
  fetchSuggestions={handleFetch}
  placeholder="搜索 GitHub 用户"
/>
```

**自定义渲染：**
```tsx
const renderOption = (item: DataSourceType) => {
  const player = item as DataSourceType<{ number: number }>
  return (
    <>
      <b>{player.value}</b>
      <span>号码: {player.number}</span>
    </>
  )
}

<AutoComplete
  fetchSuggestions={handleFetch}
  renderOption={renderOption}
/>
```

**实现细节：**

1. **组件结构**
   - `AutoComplete`：主组件
   - 内部使用 `Input` 组件
   - 下拉列表使用 `Transition` 包裹

2. **关键 Hooks**
   - `useDebounce`：防抖处理输入值
   - `useClickOutside`：点击外部关闭下拉
   - `useRef`：存储 `triggerSearch` 标志，控制是否触发搜索

3. **状态管理**
   - `inputValue`：输入框值
   - `suggestions`：建议列表
   - `loading`：加载状态
   - `showDropdown`：下拉显示状态
   - `highlightIndex`：高亮索引

4. **搜索触发逻辑**
   - 用户输入时设置 `triggerSearch.current = true`
   - 选择项时设置 `triggerSearch.current = false`
   - `useEffect` 中检查 `triggerSearch.current` 决定是否搜索

5. **防抖实现**
```tsx
const debouncedValue = useDebounce(inputValue, 300)

useEffect(() => {
  if (debouncedValue && triggerSearch.current) {
    // 执行搜索
  }
}, [debouncedValue])
```

### 4. 竞对方案及其优缺点对比

**Ant Design AutoComplete：**
- ✅ 优点：功能完善，支持更多配置（过滤、排序、自定义渲染）
- ❌ 缺点：体积大，API 复杂

**Material-UI Autocomplete：**
- ✅ 优点：Material Design 风格，功能强大
- ❌ 缺点：体积大，样式定制困难

**React-Select：**
- ✅ 优点：功能丰富，支持多选、分组等
- ❌ 缺点：主要用于 Select，AutoComplete 功能相对简单

**Downshift：**
- ✅ 优点：无 UI，完全可控，灵活
- ❌ 缺点：需要自己实现 UI，开发成本高

**Vikingship AutoComplete：**
- ✅ 优点：轻量级，API 简洁，易于理解
- ❌ 缺点：功能相对简单，不支持复杂过滤逻辑

### 5. 延伸到的技术栈的八股

**React Hooks：**
- `useState`：状态管理
- `useEffect`：副作用处理，监听防抖值变化
- `useRef`：存储可变值（triggerSearch）
- 自定义 Hooks：`useDebounce`、`useClickOutside`

**防抖（Debounce）：**
- 原理：延迟执行，在延迟期间有新输入则重新计时
- 应用：减少 API 请求次数，提升性能
- 实现：`setTimeout` + `clearTimeout`

**事件处理：**
- 键盘事件：`onKeyDown`、`keyCode`
- 鼠标事件：`onClick`
- 输入事件：`onChange`

**动画：**
- `react-transition-group`：过渡动画库
- `CSSTransition`：CSS 过渡组件
- 动画类名：`zoom-in-top`、`zoom-in-bottom` 等

**TypeScript：**
- 泛型约束：`DataSourceType<T = {}>`
- 类型扩展：`Omit<InputProps, 'onSelect' | 'onChange'>`
- 联合类型：`DataSourceType[] | Promise<DataSourceType[]>`

**React 模式：**
- 受控组件：通过 `value` 和 `onChange` 控制
- 组合模式：支持自定义渲染函数
- 回调模式：`onSelect`、`onChange` 等回调

### 6. 如果不用库让你自己实现该怎么做

**核心实现步骤：**

1. **实现防抖 Hook**
```tsx
const useDebounce = (value: string, delay: number) => {
  const [debouncedValue, setDebouncedValue] = useState(value)
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)
    
    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])
  
  return debouncedValue
}
```

2. **实现点击外部关闭**
```tsx
const useClickOutside = (ref: RefObject<HTMLElement>, handler: Function) => {
  useEffect(() => {
    const listener = (event: MouseEvent) => {
      if (!ref.current || ref.current.contains(event.target as HTMLElement)) {
        return
      }
      handler(event)
    }
    
    document.addEventListener('click', listener)
    return () => {
      document.removeEventListener('click', listener)
    }
  }, [ref, handler])
}
```

3. **实现键盘导航**
```tsx
const handleKeyDown = (e: KeyboardEvent) => {
  switch(e.keyCode) {
    case 38: // ↑
      setHighlightIndex(prev => Math.max(0, prev - 1))
      break
    case 40: // ↓
      setHighlightIndex(prev => Math.min(suggestions.length - 1, prev + 1))
      break
    case 13: // Enter
      if (suggestions[highlightIndex]) {
        handleSelect(suggestions[highlightIndex])
      }
      break
    case 27: // Esc
      setShowDropdown(false)
      break
  }
}
```

4. **实现搜索逻辑**
```tsx
useEffect(() => {
  if (debouncedValue && triggerSearch.current) {
    const results = fetchSuggestions(debouncedValue)
    
    if (results instanceof Promise) {
      setLoading(true)
      results.then(data => {
        setLoading(false)
        setSuggestions(data)
        setShowDropdown(data.length > 0)
      })
    } else {
      setSuggestions(results)
      setShowDropdown(results.length > 0)
    }
  } else {
    setShowDropdown(false)
  }
}, [debouncedValue])
```

5. **实现下拉列表**
```tsx
<div className="autocomplete-wrapper" ref={componentRef}>
  <input
    value={inputValue}
    onChange={handleChange}
    onKeyDown={handleKeyDown}
  />
  {showDropdown && (
    <ul className="suggestion-list">
      {loading && <li>加载中...</li>}
      {suggestions.map((item, index) => (
        <li
          key={index}
          className={index === highlightIndex ? 'active' : ''}
          onClick={() => handleSelect(item)}
        >
          {renderOption ? renderOption(item) : item.value}
        </li>
      ))}
    </ul>
  )}
</div>
```

### 7. 在此之上还能否做优化

**性能优化：**
1. **虚拟滚动**：建议列表很长时使用虚拟滚动
2. **请求缓存**：相同输入缓存结果，避免重复请求
3. **请求取消**：新输入时取消之前的请求
4. **防抖优化**：根据输入长度动态调整防抖时间

**功能增强：**
1. **高亮匹配文本**：在建议中高亮匹配的文本部分
2. **分组显示**：支持分组显示建议（如：最近搜索、热门搜索）
3. **多选支持**：支持选择多个建议项
4. **异步加载更多**：支持滚动加载更多建议
5. **自定义过滤**：支持自定义过滤逻辑
6. **空状态处理**：无结果时显示友好提示

**用户体验优化：**
1. **加载骨架屏**：加载时显示骨架屏而非简单的 spinner
2. **键盘快捷键提示**：显示键盘操作提示
3. **历史记录**：保存用户搜索历史
4. **热门推荐**：无输入时显示热门推荐
5. **输入提示**：显示输入格式提示

**代码优化：**
1. **自定义 Hook**：提取 `useAutoComplete` Hook
2. **配置化**：支持更多配置项（防抖时间、最小输入长度等）
3. **TypeScript 优化**：更严格的类型定义
4. **单元测试**：提高测试覆盖率
5. **无障碍支持**：添加 ARIA 属性，支持屏幕阅读器

**高级特性：**
1. **模糊搜索**：支持模糊匹配（如：拼音搜索）
2. **搜索建议排序**：根据相关性排序
3. **多数据源**：支持多个数据源合并
4. **实时搜索**：WebSocket 实时搜索建议
5. **国际化**：支持多语言

---

## 总结

这两个组件都体现了 React 组件开发的核心思想：
- **组件化**：将功能拆分为独立组件
- **状态管理**：合理使用 Hooks 管理状态
- **用户体验**：关注交互细节和反馈
- **可扩展性**：通过 props 和回调支持定制
- **TypeScript**：类型安全，提升开发体验

通过深入理解这些组件的实现，可以更好地掌握 React 开发的核心技能。
